# 9 虚拟内存

## 9.1 名词解释

物理地址：计算机主存的被组织为一个连续M个字节大小的单元数组，每个字节都有唯一的地址。

虚拟地址：CPU通过生成一个逻辑上的地址来访问主存，这个地址被送到内存之前，先被翻译（使用某种约定好的规则）为物理地址。

地址空间：一个非负整数地址的集合，如果地址整数连续，就是线性地址空间。

虚拟地址空间：CPU从一个有N个地址的地址空间中，**生成虚拟地址**，这个地址空间就是虚拟地址空间。

物理地址空间：从一个有N个地址的地址空间中，**生成物理地址**，这个地址空间就是物理地址空间。

## 9.2 虚拟内存的三个特点

**虚拟内存**：一个由存放在**磁盘**上的，N个连续字节大小的单元组成的数组。每个字节都有唯一的虚拟地址，作为到数组的索引，磁盘上数组的内容被缓存在主存中。

### 9.2.1 缓存

#### 9.2.1.2 分页

从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节要慢大约 100000 倍。归根到底，DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。

因此，和其他存储系统一样，磁盘（较低层）上的数**据被分割成块**，这些块作为磁盘和主存（较高层）之间的传输单元。

- 虚拟存储系统通过将虚拟内存分割为称为虚拟页（Virtual Page，VP）的大小固定的块，每个虚拟页的大小为`P = 2^p`。

- 类似地，物理内存被分割为物理页（Physical Page，PP）。

虚拟页面分为三个不相交的子集：

- 未分配的：VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。

- 已分配，未缓存的：未缓存在物理内存中的已分配页。

- 已分配，缓存的：当前已缓存在物理内存中的已分配页。

下图，展示了一个虚拟内存系统是如何使用主存作为缓存。

![img](../csapp（部分）/img/9-1.png)

示例中，展示了一个有8个虚拟页的小虚拟内存。虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理内存中。页2、5和7已经被分配了，但是当前并未缓存在主存中。

#### 9.2.1.2 页表

同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。

这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。

![img](../csapp（部分）/img/9-2.png)

上图中，展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。为了我们的目的，我们将假设每个 PTE 是由一个有效位（valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 DRAM 中。

- 如果设置了有效位，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。
  
- 如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。

- 否则，这个地址就指向该虚拟页在磁盘上的起始位置。

每次读取虚拟页时：

- 页命中：地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道 VP2 是缓存在内存中的了。所以它使用PTE中的物理内存地址（该地址指向PP1中缓存页的起始位置），构造出这个字的物理地址。

- 缺页：CPU 引用了 VP  中的一个字，VP3 并未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE3，从有效位推断出 VP3 未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，加载磁盘页到该页中，然后走页命中逻辑。

- 分配页面：例如malloc。虚拟内存的分配过程是在**磁盘上**创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。

### 9.2.2 内存管理

//todo

### 9.2.3 内存保护

//todo
