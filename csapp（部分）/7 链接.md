# 第七章 链接

链接是将各种代码和数据片段收集并组合成一个单一的文件。

本章，探索在linux系统上，如何构建和运行应用软件。

## 1程序编译执行的总体过程

考虑有两个C文件：

```c
// main.c
int sum(int *a, int n);

int array[2] = {1, 2};

int main()
{
    int val = sum(array, 2);
    return val;
}
```

```c
// sum.c
int sum(int *a, int n)
{
    int i, s = 0;
    
    for (i = 0; i < n; i++) {
        s += a[i];
    }
    return s;
}
```

大多数编译系统提供编译器驱动程序（compiler driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用 GNU 编译系统构造示例程序，我们就要通过在 shell 中输入下列命令来调用 GCC 驱动程序

编译链接两个可C文件成为可执行文件的过程如图:

![img](img/7-1.png)

第一步，对源代码做预处理操作，主要是处理那些源文件和头文件中以 # 开头的命令（比如 #include、#define、#ifdef 等），并删除程序中所有的注释 // 和 /*...*/等，使用`gcc -E`参数：

```shell
#运行  C 预处理器（cpp），将 C 的源程序 main.c 翻译成一个中间文件 main.i
cpp main.c main.i
# 或者直接使用gcc -E选项
gcc -E main.c -o main.i
```

第二步，就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，编译加工为当前机器支持的汇编代码。将main.i翻译为ASCII汇编语言文件main.s，使用`gcc -S`参数：

```shell
# 运行 C 编译器（cc1），它将 main.i 翻译成一个汇编语言文件 main.s
cc1 main.i -o main.s
# 或者直接使用gcc -S 选项
gcc -S main.i -o main.s
```

第三步，对已得到的 main.s 执行汇编操作，并得到相应的目标文件。所谓目标文件，其本质为二进制文件，但由于尚未经过链接操作，所以无法直接运行。使用`gcc -c`选项：

```shell
# 者直接使用汇编器，将 main.s 翻译成一个可重定位目标文件
as main.s -o main.o
# 或者直接使用gcc -c选项
gcc -c main.s -o main.o
```

第四步，运行链接器程序ld，将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件。或者使用`gcc -c`命令：

```shell
# 运行链接器程序ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件
ld main.o sun.o -o proc
# 或者直接使用gcc -c选项
gcc -c main.o sun.o -o proc
```

最后，shell调用操作系统中一个叫做加载器（loader）的函数，它将可执行文件proc中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

## 2可重定位文件

汇编器编译汇编语言文件，生成**可重定位文件**，包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

### 2.1可重定位文件构成

下图展示了一个典型的 ELF 可重定位目标文件的格式。

![img](img/7-3.png)

- ELF头：ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如 X86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。

- 节头部表：不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。

- .text：已编译程序的机器代码。

- .rodata：只读数据，比如 printf 语句中的格式串和switch语句的跳转表。

- .data：已初始化的全局和静态 C 变量，需要在文件保存初始值。

- .bss（Better Save Space）：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
  
- .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。

- .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。
  
- .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

- .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。

- .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

- .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

### 2.2符号表

符号：编译器输出到汇编语言.s文件中的符号，再由汇编器构造，并生成到.o文件中的`.symtab`节。

用来描述链接过程中，可大致分为三种不同的符号：

(1) 模块自身定义，并能够被其他模块引用的全局符号；

(2) 其他模块定义，被自身引用的全局符号；

(3) 只被自身模块定义和引用的模块，如被static修饰的C函数和全局变量。

.symtab 节中包含 ELF 符号表。这张符号表包含一个条目的数组，每个数据元素表述一个符号。下图展示了每个条目的格式。

```c
typedef struct {
    // 字符串表中的字节偏移
    int     name;      /* String table offset */
    // 数据or函数
    char    type:4,    /* Function or data (4 bits) */
    //全局or局部福海
            binding:4; /* Local or global (4 bits) */
    //保留字段
    char    reserved;  /* Unused */
    //本符号指向数据的节索引,也可以认为是到节头部表的偏移
    short   section;   /* Section header index */
    //节内数据的偏移，或者干脆就是绝对地址
    long    value;     /* Section offset or absolute address */
    //符号指向数据的大小
    long    size;      /* Object size in bytes */
} Elf64_Symbol;
```

有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：

- ABS 代表不该被重定位的符号；

- UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；

- COMMON 表示还未被分配位置的未初始化的**全局变量**。

以下是对7.1中生成main.o文件，使用`readelf -a main.o`查看符号表：

![img](img/7-4.jpg)

### 2.3符号解析
